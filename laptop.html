<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 極致擬真透明筆電 - 230度背折模式</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #0d1526 0%, #020202 100%);
            font-family: 'Inter', -apple-system, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        .ui-overlay {
            position: absolute;
            top: 40px;
            left: 40px;
            color: rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }

        .ui-overlay h1 {
            margin: 0;
            font-size: 0.7rem;
            font-weight: 300;
            letter-spacing: 10px;
            text-transform: uppercase;
        }
    </style>
</head>

<body>

    <div id="canvas-container"></div>

    <div class="ui-overlay">
        <h1>CRYSTAL CORE // 230° REVERSE AXIS v3.4</h1>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls, laptopGroup;

        function init() {
            scene = new THREE.Scene();

            // 攝影機設定：針對背折狀態調整視角
            camera = new THREE.PerspectiveCamera(24, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 8, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.4;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0.5, 0);

            // --- 燈光環境 ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const rectLight = new THREE.RectAreaLight(0xffffff, 6, 15, 15);
            rectLight.position.set(5, 12, 5);
            rectLight.lookAt(0, 0, 0);
            scene.add(rectLight);

            const rimLight = new THREE.PointLight(0x77aaff, 2, 25);
            rimLight.position.set(-10, 8, -5);
            scene.add(rimLight);

            // --- 環境反射 ---
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            const envScene = new THREE.Scene();
            const lightPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            lightPlane.position.set(0, 20, -15);
            envScene.add(lightPlane);
            const envMap = pmremGenerator.fromScene(envScene).texture;
            scene.environment = envMap;

            // --- 建立模型 ---
            laptopGroup = new THREE.Group();
            createPremiumLaptop(envMap);
            scene.add(laptopGroup);

            // 落地光暈
            const shadowTex = createShadowTexture();
            const shadowPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(15, 15),
                new THREE.MeshBasicMaterial({ map: shadowTex, transparent: true, opacity: 0.4 })
            );
            shadowPlane.rotation.x = -Math.PI / 2;
            shadowPlane.position.y = -0.4;
            scene.add(shadowPlane);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createScreenTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1440;
            const ctx = canvas.getContext('2d');

            // 背景漸層
            const grad = ctx.createLinearGradient(0, 0, 2048, 1440);
            grad.addColorStop(0, '#020a2f');
            grad.addColorStop(0.5, '#0a2a5a');
            grad.addColorStop(1, '#020a2f');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 2048, 1440);

            // 中央光感
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = '#0066ff';
            ctx.beginPath(); ctx.ellipse(1024, 720, 1200, 600, 0, 0, Math.PI * 2); ctx.fill();

            // 裝飾線條
            ctx.globalAlpha = 1.0;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.lineWidth = 4;
            ctx.strokeRect(80, 80, 1888, 1280);

            // 文字內容
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 90px sans-serif';
            ctx.fillText('REVERSE FOLD', 180, 300);
            ctx.font = 'bold 120px sans-serif';
            ctx.fillText('230° BACKWARD', 180, 450);

            ctx.font = '40px sans-serif';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fillText('CONVERTIBLE MODE ACTIVE', 180, 580);
            ctx.fillText('DISPLAY ORIENTATION: REVERSED', 180, 640);

            return new THREE.CanvasTexture(canvas);
        }

        function createPremiumLaptop(envMap) {
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.05,
                roughness: 0.02,
                transmission: 0.98,
                thickness: 0.8,
                ior: 1.55,
                transparent: true,
                clearcoat: 1.0,
                clearcoatRoughness: 0.01,
                envMapIntensity: 2.5
            });

            const bezelMat = new THREE.MeshPhysicalMaterial({
                color: 0x000000,
                roughness: 0.05,
                transparent: true,
                opacity: 0.96
            });

            // 1. 機身 (Base)
            const body = new THREE.Mesh(new THREE.BoxGeometry(4.8, 0.1, 3.2), glassMat);
            laptopGroup.add(body);

            // 2. 鍵盤區
            const kbGroup = new THREE.Group();
            for (let i = -6; i <= 6; i++) {
                for (let j = -2; j <= 2; j++) {
                    let kw = 0.24, kh = 0.24;
                    let xOff = i * 0.32;
                    if (j === 2 && i >= -1 && i <= 1) {
                        if (i !== 0) continue;
                        kw = 1.4; xOff = 0;
                    }
                    const key = new THREE.Mesh(new THREE.BoxGeometry(kw, 0.05, kh), glassMat);
                    key.position.set(xOff, 0.08, j * 0.35 - 0.4);

                    const glow = new THREE.Mesh(new THREE.BoxGeometry(kw * 0.8, 0.01, kh * 0.8), new THREE.MeshBasicMaterial({
                        color: 0x00aaff, transparent: true, opacity: 0.4
                    }));
                    glow.position.set(xOff, 0.06, j * 0.35 - 0.4);
                    kbGroup.add(glow, key);
                }
            }
            laptopGroup.add(kbGroup);

            // 3. 螢幕總成 (Lid Assembly)
            const lidGroup = new THREE.Group();
            lidGroup.position.set(0, 0.05, -1.6);

            const hinge = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 4.8, 32), bezelMat);
            hinge.rotation.z = Math.PI / 2;
            lidGroup.add(hinge);

            const lidBack = new THREE.Mesh(new THREE.BoxGeometry(4.8, 0.06, 3.2), glassMat);
            lidBack.position.set(0, 0, 1.6);
            lidGroup.add(lidBack);

            const bezel = new THREE.Mesh(new THREE.PlaneGeometry(4.6, 3.1), bezelMat);
            bezel.rotation.x = Math.PI / 2;
            bezel.position.set(0, -0.031, 1.6);
            lidGroup.add(bezel);

            const screenTex = createScreenTexture();
            const panel = new THREE.Mesh(new THREE.PlaneGeometry(4.4, 2.9), new THREE.MeshBasicMaterial({
                map: screenTex, transparent: true, opacity: 0.98, side: THREE.DoubleSide
            }));
            panel.rotation.x = Math.PI / 2;
            panel.position.set(0, -0.035, 1.6);
            lidGroup.add(panel);

            const topGlass = new THREE.Mesh(new THREE.PlaneGeometry(4.4, 2.9), new THREE.MeshPhysicalMaterial({
                color: 0xffffff, transmission: 0.1, roughness: 0.01, transparent: true, opacity: 0.4, ior: 1.5
            }));
            topGlass.rotation.x = Math.PI / 2;
            topGlass.position.set(0, -0.036, 1.6);
            lidGroup.add(topGlass);

            // --- 關鍵修改：螢幕角度設為 230 度 ---
            lidGroup.rotation.x = Math.PI * (230 / 180);

            laptopGroup.add(lidGroup);
        }

        function createShadowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            grad.addColorStop(0, 'rgba(0, 100, 255, 0.9)');
            grad.addColorStop(0.3, 'rgba(0, 0, 0, 1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (laptopGroup) {
                laptopGroup.rotation.y += 0.0015;
                laptopGroup.position.y = Math.sin(Date.now() * 0.0008) * 0.05 + 0.1;
            }
            controls.update();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>